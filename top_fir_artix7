`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// top_fir_artix7.v
// Top wrapper for fir_synth. Reads rom_init.mem, steps through samples, captures
// outputs and exposes probe signals for an ILA.
//
// Usage:
// - Put rom_init.mem in the Vivado project (Design Sources).
// - Set NUM_SAMPLES to number of lines in rom_init.mem.
// - Add an ILA IP (probe widths: N3, N2, 32) and connect to probe_* signals.
// - Provide an XDC mapping clk and rst_n to board pins.
//////////////////////////////////////////////////////////////////////////////////
module top_fir_artix7 (
    input  wire clk,      // board clock (e.g. 100 MHz)
    input  wire rst_n     // active-low reset (button). If no reset button, tie to 1'b1 for debug
);

    // -------------------------------------------------------------------------
    // Parameters - adjust if needed
    parameter integer N2 = 16;           // input width
    parameter integer N3 = 32;           // FIR accumulator / output width
    parameter integer NUM_SAMPLES = 100; // number of lines in rom_init.mem
    // -------------------------------------------------------------------------

    // ---------------------- ROM (initialized from file) ----------------------
    // rom_init.mem must contain exactly NUM_SAMPLES lines, each a N2-bit binary string
    reg signed [N2-1:0] rom [0:NUM_SAMPLES-1];
    initial begin
        // filename must match the file you added to the project. If you named it mem.mem,
        // change the string accordingly.
        $readmemb("mem.mem", rom);
    end

    // ---------------------- optional slow-down divider -----------------------
    // Uncomment and use clk_slow for the FIR and addr stepping if you want a slow
    // sample rate (avoid this if you need max speed or pipelined FIR).
    //
    // reg [23:0] clk_div;
    // wire clk_slow;
    // always @(posedge clk or negedge rst_n) begin
    //     if (!rst_n) clk_div <= 0;
    //     else clk_div <= clk_div + 1;
    // end
    // assign clk_slow = clk_div[19]; // very slow derived clock (~100MHz/(2^20))
    //
    // If you use clk_slow, instantiate fir_synth with .clk(clk_slow) instead of .clk(clk)
    // and use clk_slow in the addr always block below.

    // ---------------------- address controller -------------------------------
    reg [31:0] addr;               // address into ROM
    wire signed [N2-1:0] rom_dout;
    assign rom_dout = rom[addr];

    // ---------------------- instantiate FIR -------------------------------
    wire signed [N3-1:0] dout;
    wire [31:0] sample_idx;
    wire done;

    // instantiate fir_synth; ensure SAMPLES matches NUM_SAMPLES
    fir_synth #(
        .TAP(8),
        .N1(8),
        .N2(N2),
        .N3(N3),
        .SAMPLES(NUM_SAMPLES)
    ) u_fir (
        .clk(clk),          // or clk_slow if you enabled slow divider
        .rst_n(rst_n),
        .en(1'b1),          // always enabled, one sample per clock
        .din(rom_dout),
        .dout(dout),
        .sample_idx(sample_idx),
        .done(done)
    );

    // increment address on each clock until FIR indicates done
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            addr <= 0;
        end else begin
            if (!done) begin
                addr <= addr + 1;
            end else begin
                addr <= addr; // hold at last value when done
            end
        end
    end

    // ---------------------- capture outputs (optional) ------------------------
    // Here we store outputs into an on-chip RAM; optional - you can comment this if not needed.
    reg signed [N3-1:0] out_ram [0:NUM_SAMPLES-1];
    always @(posedge clk) begin
        // store output (note: dout corresponds to previous cycle's accumulator)
        out_ram[addr] <= dout;
    end

    // ---------------------- probe signals for ILA ----------------------------
    wire [N2-1:0] probe_input  = rom_dout;
    wire [N3-1:0] probe_output = dout;
    wire [31:0]   probe_addr   = addr;

    // ---------------------- example ILA instantiation (commented) -----------
    // If you generated an ILA named ila_0 (Vivado creates ila_0/ila_0_0 etc.), instantiate
    // the wrapper here and connect probes. Alternatively, add ILA in block design
    // and connect signals there.
    //
    // ila_0 your_ila_inst (
    //     .clk(clk),
    //     .probe0(probe_output), // width N3
    //     .probe1(probe_input),  // width N2
    //     .probe2(probe_addr)    // width 32
    // );
    //
    // (Generate the ILA IP first from IP Catalog, then uncomment and adjust instance name.)

endmodule
